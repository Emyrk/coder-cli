package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"cdr.dev/coder-cli/internal/entclient"
	"github.com/spf13/pflag"

	"go.coder.com/cli"
	"go.coder.com/flog"
)

const (
	sshConfigStartToken   = "# ------------START-CODER-ENTERPRISE-----------"
	sshConfigStartMessage = `# The following has been auto-generated by "coder config-ssh"
# to make accessing your Coder Enterprise environments easier.
#
# To remove this blob, run:
#
#    coder config-ssh --remove
#
# You should not hand-edit this section, unless you are deleting it.`
	sshConfigEndToken = "# ------------END-CODER-ENTERPRISE------------"
)

type configSSHCmd struct {
	filepath string
	remove   bool
}

func (cmd *configSSHCmd) Spec() cli.CommandSpec {
	return cli.CommandSpec{
		Name:  "config-ssh",
		Usage: "",
		Desc:  "adds your Coder Enterprise environments to ~/.ssh/config",
	}
}

func (cmd *configSSHCmd) RegisterFlags(fl *pflag.FlagSet) {
	fl.BoolVar(&cmd.remove, "remove", false, "remove the auto-generated Coder Enterprise ssh config")
	defaultPath := filepath.Join(os.Getenv("HOME"), ".ssh", "config")
	fl.StringVar(&cmd.filepath, "config-path", defaultPath, "overide the default path of your ssh config file")
}

func (cmd *configSSHCmd) Run(fl *pflag.FlagSet) {
	currentConfiguration, err := readStr(cmd.filepath)
	if err != nil {
		flog.Fatal("failed to read ssh config file %q: %v", cmd.filepath, err)
	}

	startIndex := strings.Index(currentConfiguration, sshConfigStartToken)
	endIndex := strings.Index(currentConfiguration, sshConfigEndToken)

	if cmd.remove {
		if startIndex == -1 || endIndex == -1 {
			flog.Fatal("the Coder Enterprise ssh configuration section could not be safely deleted or does not exist.")
		}
		currentConfiguration = currentConfiguration[:startIndex-1] + currentConfiguration[endIndex+len(sshConfigEndToken)+1:]

		err = writeStr(cmd.filepath, currentConfiguration)
		if err != nil {
			flog.Fatal("failed to write to ssh config file %q: %v", cmd.filepath, err)
		}

		return
	}

	entClient := requireAuth()

	me, err := entClient.Me()
	if err != nil {
		flog.Fatal("failed to fetch username: %v", err)
	}
	envs := getEnvs(entClient)

	if startIndex == -1 || endIndex == -1 {
		newConfiguration := makeNewConfigs(me.Username, envs)

		err = writeStr(cmd.filepath, currentConfiguration+newConfiguration)
		if err != nil {
			flog.Fatal("failed to write new configurations to ssh config file %q: %v", cmd.filepath, err)
		}

		return
	}
	currentConfiguration = currentConfiguration[:startIndex-1] + currentConfiguration[endIndex+len(sshConfigEndToken)+1:]
	newConfiguration := makeNewConfigs(me.Username, envs)

	err = writeStr(cmd.filepath, currentConfiguration+newConfiguration)
	if err != nil {
		flog.Fatal("failed to write new configurations to ssh config file %q: %v", cmd.filepath, err)
	}
}

func makeNewConfigs(userName string, envs []entclient.Environment) string {
	newConfiguration := fmt.Sprintf("\n%s\n%s\n\n", sshConfigStartToken, sshConfigStartMessage)
	for _, env := range envs {
		newConfiguration += makeConfig(userName, env.Name)
	}
	newConfiguration += fmt.Sprintf("\n%s\n", sshConfigEndToken)

	return newConfiguration
}

func makeConfig(userName, envName string) string {
	return fmt.Sprintf(
		`Host coder:%s
    HostName %s
    User %s-%s
    Port 2222
    KeepAlive=yes
    ConnectTimeout=0
`, envName, "MOCK-SSHPROXY-IP", userName, envName) // TODO: get real ssh proxy ip address
}

func writeStr(filename, data string) error {
	return ioutil.WriteFile(filename, []byte(data), 0777)
}

func readStr(filename string) (string, error) {
	contents, err := ioutil.ReadFile(filename)
	if err != nil {
		return "", err
	}
	return string(contents), nil
}
