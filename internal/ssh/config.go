package ssh

import (
	"context"
	"fmt"
	"os"
	"os/user"
	"path/filepath"
	"sort"
	"strings"

	sshconfig "github.com/kevinburke/ssh_config"
	"golang.org/x/xerrors"
)

const (
	configStartToken = "# ------------START-CODER-ENTERPRISE-----------\n"
	configComment    = `
# The following has been auto-generated by "coder config-ssh"
# to make accessing your Coder workspaces easier.
#
# To remove this blob, run:
#
#    coder config-ssh --remove
#
# You should not hand-edit this section, unless you are deleting it.

`
	configEndToken = "\n# ------------END-CODER-ENTERPRISE------------\n"

	configFilePerms = 0600
)

var (
	DefaultConfigPath = filepath.Join("~", ".ssh", "config")
)

// Config is a utility object for interacting with Coder SSH config.
// It is not intended to be a general purpose SSH Config utility and only touches
// Coder-generated SSH config.
type Config struct {
	filepath string
	// raw is the raw, initial config file. This field is not considered immutable and may be
	// mutated over the lifecycle of the Config object.
	raw string
	// coder only contains config generated by the CLI.
	coder *sshconfig.Config
}

// ReadConfig reads the config from configPath. If configPath is empty it reads
// from the default path '~/.ssh/config'.
func ReadConfig(ctx context.Context, configPath string) (*Config, error) {
	var err error
	if configPath == "" {
		configPath, err = defaultConfigPath()
		if err != nil {
			return nil, xerrors.Errorf("default config path: %w", err)
		}
	}

	// Expand path in case of '~'.
	configPath, err = expandPath(configPath)
	if err != nil {
		return nil, xerrors.Errorf("expand path: %w", err)
	}

	raw, err := os.ReadFile(configPath)
	if os.IsNotExist(err) {
		return &Config{
			raw:      "",
			coder:    &sshconfig.Config{},
			filepath: configPath,
		}, nil
	}
	if err != nil {
		return nil, xerrors.Errorf("read config file: %w", err)
	}

	cc := extractCoderConfig(string(raw))
	conf, err := sshconfig.Decode(strings.NewReader(cc))
	if err != nil {
		return nil, xerrors.Errorf("parse config: %w", err)
	}

	return &Config{
		raw:      string(raw),
		coder:    conf,
		filepath: configPath,
	}, nil
}

// Remove removes all Coder-generated config.
func (c *Config) Remove() bool {
	c.coder.Hosts = []*sshconfig.Host{}
	return c.removeOldConfig()
}

// ContainsHost checks to see if the provided host is an entry in the Coder config.
func (c *Config) ContainsHost(host string) bool {
	for _, h := range c.coder.Hosts {
		if len(h.Patterns) == 0 {
			return false
		}
		// There should only be one entry per host config. The reason 'Patterns' is a slice
		// to begin with is because you can have a host entry like 'Host host1 host2'
		if h.Patterns[0].String() == host {
			return true
		}
	}
	return false
}

// AddHost adds a new entry for the provided host.
func (c *Config) AddHost(h Host) {
	c.coder.Hosts = append(c.coder.Hosts, h.config())
}

// Save writes the config to disk.
func (c *Config) Save() error {
	// We don't care if the old config existed or not. All the hosts we want to write are
	// accounted for in c.coder.Hosts so we can unconditionally delete the old and regenerate.
	_ = c.removeOldConfig()
	c.writeConfig()

	err := os.MkdirAll(filepath.Dir(c.filepath), os.ModePerm)
	if err != nil {
		return xerrors.Errorf("make config dir: %w", err)
	}

	err = os.WriteFile(c.filepath, []byte(c.raw), configFilePerms)
	if err != nil {
		return xerrors.Errorf("write file: %w", err)
	}
	return nil
}

// writeConfig writes the Coder config to the config file.
// If no hosts exists (in the event someone called Remove)
// this is a nop.
func (c *Config) writeConfig() {
	// If no hosts exist we should just exit.
	if len(c.coder.Hosts) == 0 {
		return
	}

	// We purposefully don't add this initial newline to the configStartToken const
	// to avoid cases where the user may delete the newline preceding the token.
	coder := fmt.Sprintf("\n%s%s", configStartToken, configComment)

	// Sort the hosts so that we write everything in alphabetical order.
	sort.Slice(c.coder.Hosts, func(i, j int) bool {
		return c.coder.Hosts[i].Patterns[0].String() < c.coder.Hosts[j].Patterns[0].String()
	})

	coder += c.coder.String()
	coder += configEndToken

	c.raw += coder
}

func (c *Config) removeOldConfig() bool {
	startIndex := strings.Index(c.raw, configStartToken)
	endIndex := strings.Index(c.raw, configEndToken)

	if startIndex == -1 || endIndex == -1 {
		return false
	}
	if startIndex == 0 {
		c.raw = c.raw[endIndex+len(configEndToken):]
		return true
	}
	c.raw = c.raw[:startIndex-1] + c.raw[endIndex+len(configEndToken):]
	return true
}

type Host struct {
	Host           string
	Username       string
	Workspace      string
	PrivateKeyPath string
	CoderBinPath   string
	Tunnel         bool
}

// config returns the config as an sshconfig.Host.
func (h Host) config() *sshconfig.Host {
	return &sshconfig.Host{
		Patterns: []*sshconfig.Pattern{mustParseHostname(h.Workspace)},
		Nodes:    h.values(),
	}
}

// values returns the key value config for a host entry.
func (h Host) values() []sshconfig.Node {
	if h.Tunnel {
		return []sshconfig.Node{
			kv("Hostname", coderHost(h.Workspace)),
			kv("ProxyCommand", fmt.Sprintf("%s tunnel %s 12213 stdio", h.Workspace, h.CoderBinPath)),
			kv("StrictHostKeyChecking", "no"),
			kv("ConnectTimeout", "0"),
			kv("IdentitiesOnly ", "yes"),
			// We use '=' to account for potential whitespace in the filepath.
			kv("IdentityFile", fmt.Sprintf("= %q", h.PrivateKeyPath)),
		}
	}

	return []sshconfig.Node{
		kv("Hostname", h.Host),
		kv("User", fmt.Sprintf("%s-%s", h.Username, h.Workspace)),
		kv("StrictHostKeyChecking", "no"),
		kv("ConnectTimeout", "0"),
		kv("IdentitiesOnly", "yes"),
		// We use '=' to account for potential whitespace in the filepath.
		kv("IdentityFile", fmt.Sprintf("= %q", h.PrivateKeyPath)),
	}
}

// extractCoderConfig extracts Coder-generated config (comments are intentionally discarded)
// from the config.
func extractCoderConfig(config string) string {
	startIndex := strings.Index(config, configStartToken)
	endIndex := strings.Index(config, configEndToken)

	if startIndex == -1 || endIndex == -1 {
		return ""
	}

	// Grab the text beginning after the start Token, up to the
	// start of the end token.
	return config[startIndex+len(configStartToken)+len(configComment) : endIndex]
}

// expandPath expands '~' to the user's home dir. If the path does not start with '~'
// then path is returned unmodified.
func expandPath(path string) (string, error) {
	if !strings.HasPrefix(path, "~") {
		return path, nil
	}

	u, err := user.Current()
	if err != nil {
		return "", xerrors.Errorf("current user: %w", err)
	}
	return strings.Replace(path, "~", u.HomeDir, 1), nil

}

func defaultConfigPath() (string, error) {
	return expandPath(DefaultConfigPath)
}

func coderHost(name string) string {
	return "coder." + name
}

func kv(k, v string) *sshconfig.KV {
	const indent = "   "
	return &sshconfig.KV{
		// Pretty jank but sshconfig doesn't make it easy
		// to add host config.
		Key:   indent + k,
		Value: v,
	}
}

func mustParseHostname(name string) *sshconfig.Pattern {
	// NewPattern can only fail if the regex fails to parse
	// or if it is passed an empty string. Since both aren't
	// reastically possible let's just panic here instead
	// of bubbling up an error. It also ruins the niceness
	// of the API.
	pattern, err := sshconfig.NewPattern(coderHost(name))
	if err != nil {
		panic(err)
	}

	return pattern
}
