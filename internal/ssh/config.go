package ssh

import (
	"context"
	"fmt"
	"os"
	"os/user"
	"path/filepath"
	"sort"
	"strings"

	sshconfig "github.com/kevinburke/ssh_config"
	"golang.org/x/xerrors"
)

const (
	configStartToken = "# ------------START-CODER-ENTERPRISE-----------\n"
	configComment    = `# The following has been auto-generated by "coder config-ssh"
# to make accessing your Coder workspaces easier.
#
# To remove this blob, run:
#
#    coder config-ssh --remove
#
# You should not hand-edit this section, unless you are deleting it.
`
	configEndToken = "# ------------END-CODER-ENTERPRISE------------\n"

	configFilePerms = 0600
)

var (
	DefaultConfigPath = filepath.Join("~", ".ssh", "config")
)

type Config struct {
	filepath string
	raw      string
	// coder only contains config generated by the CLI.
	coder *sshconfig.Config
}

func (c *Config) ContainsHost(host string) bool {
	for _, h := range c.coder.Hosts {
		if len(h.Patterns) == 0 {
			return false
		}
		// There should only be one entry per host config. The reason 'Patterns' is a slice
		// to begin with is because you can have a host entry like 'Host host1 host2'
		if h.Patterns[0].String() == host {
			return true
		}
	}
	return false
}

func (c *Config) Remove() bool {
	c.coder.Hosts = []*sshconfig.Host{}
	return c.removeOldConfig()
}

func (c *Config) AddHost(h Host) {
	c.coder.Hosts = append(c.coder.Hosts, h.config())
}

func (c *Config) Write() error {
	// We don't care if the old config existed or not.
	_ = c.removeOldConfig()
	c.writeConfig()

	err := os.MkdirAll(filepath.Dir(c.filepath), os.ModePerm)
	if err != nil {
		return xerrors.Errorf("make config dir: %w", err)
	}

	err = os.WriteFile(c.filepath, []byte(c.raw), configFilePerms)
	if err != nil {
		return xerrors.Errorf("write file: %w", err)
	}
	fmt.Println("coderConfig: ", c.coder.String())
	return nil
}

func (c *Config) writeConfig() {
	coder := fmt.Sprintf("\n%s%s", configStartToken, configComment)

	sort.Slice(c.coder.Hosts, func(i, j int) bool {
		return c.coder.Hosts[i].Patterns[0].String() < c.coder.Hosts[j].Patterns[0].String()
	})

	coder += c.coder.String()
	coder += fmt.Sprintf("%s\n", configEndToken)

	c.raw += coder
}

func (c *Config) removeOldConfig() bool {
	startIndex := strings.Index(c.raw, configStartToken)
	endIndex := strings.Index(c.raw, configEndToken)

	if startIndex == -1 || endIndex == -1 {
		return false
	}
	if startIndex == 0 {
		c.raw = c.raw[endIndex+len(configEndToken)+1:]
		return true
	}
	c.raw = c.raw[:startIndex-1] + c.raw[endIndex+len(configEndToken):]
	return true
}

type Host struct {
	Host           string
	Username       string
	Workspace      string
	PrivateKeyPath string
	CoderBinPath   string
	Tunnel         bool
}

// config returns the config as an sshconfig.Host.
func (h Host) config() *sshconfig.Host {
	return &sshconfig.Host{
		Patterns: []*sshconfig.Pattern{mustParseHostname(h.Workspace)},
		Nodes:    h.values(),
	}
}

// values returns the key value config for a host entry.
func (h Host) values() []sshconfig.Node {
	if h.Tunnel {
		return []sshconfig.Node{
			kv("Hostname", coderHost(h.Workspace)),
			kv("ProxyCommand", fmt.Sprintf("%s tunnel %s 12213 stdio", h.Workspace, h.CoderBinPath)),
			kv("StrictHostKeyChecking", "no"),
			kv("ConnectTimeout", "0"),
			kv("IdentitiesOnly ", "yes"),
			kv("IdentityFile", h.PrivateKeyPath),
		}
	}

	return []sshconfig.Node{
		kv("Hostname", h.Host),
		kv("User", fmt.Sprintf("%s-%s", h.Username, h.Workspace)),
		kv("StrictHostKeyChecking", "no"),
		kv("ConnectTimeout", "0"),
		kv("IdentitiesOnly", "yes"),
		kv("IdentityFile", h.PrivateKeyPath),
	}
}

func extractCoderConfig(raw string) string {
	startIndex := strings.Index(raw, configStartToken)
	endIndex := strings.Index(raw, configEndToken)

	if startIndex == -1 || endIndex == -1 {
		return ""
	}

	// Grab the text beginning after the start Token, up to the
	// start of the end token.
	return raw[startIndex+len(configStartToken)+len(configComment)-1 : endIndex]
}

func ReadConfig(ctx context.Context, configPath string) (*Config, error) {
	var err error
	if configPath == "" {
		configPath, err = defaultConfigPath()
		if err != nil {
			return nil, xerrors.Errorf("default config path: %w", err)
		}
	}

	configPath, err = expandPath(configPath)
	if err != nil {
		return nil, xerrors.Errorf("expand path: %w", err)
	}

	raw, err := os.ReadFile(configPath)
	if os.IsNotExist(err) {
		return &Config{
			raw:      "",
			coder:    &sshconfig.Config{},
			filepath: configPath,
		}, nil
	}
	if err != nil {
		return nil, xerrors.Errorf("read config file: %w", err)
	}

	cc := extractCoderConfig(string(raw))
	fmt.Printf("coder config: %v\n", cc)
	conf, err := sshconfig.Decode(strings.NewReader(cc))
	if err != nil {
		return nil, xerrors.Errorf("parse config: %w", err)
	}

	return &Config{
		raw:      string(raw),
		coder:    conf,
		filepath: configPath,
	}, nil
}

func expandPath(path string) (string, error) {
	if !strings.HasPrefix(path, "~") {
		return path, nil
	}

	u, err := user.Current()
	if err != nil {
		return "", xerrors.Errorf("current user: %w", err)
	}
	return strings.Replace(path, "~", u.HomeDir, 1), nil

}

func defaultConfigPath() (string, error) {
	return expandPath(DefaultConfigPath)
}

func coderHost(name string) string {
	return "coder." + name
}

func kv(k, v string) *sshconfig.KV {
	const indent = "   "
	return &sshconfig.KV{
		// Pretty jank but sshconfig doesn't make it easy
		// to add host config.
		Key:   indent + k,
		Value: v,
	}
}

func mustParseHostname(name string) *sshconfig.Pattern {
	// NewPattern can only fail if the regex fails to parse
	// or if it is passed an empty string. Since both aren't
	// reastically possible let's just panic here instead
	// of bubbling up an error. It also ruins the niceness
	// of the API.
	pattern, err := sshconfig.NewPattern(coderHost(name))
	if err != nil {
		panic(err)
	}

	return pattern
}
