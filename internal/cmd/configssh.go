package cmd

import (
	"context"
	"fmt"
	"net/url"
	"os"

	"cdr.dev/coder-cli/pkg/clog"

	"github.com/spf13/cobra"
	"golang.org/x/xerrors"

	"cdr.dev/coder-cli/coder-sdk"
	"cdr.dev/coder-cli/internal/coderutil"
	"cdr.dev/coder-cli/internal/ssh"
)

const sshStartToken = "# ------------START-CODER-ENTERPRISE-----------"
const sshStartMessage = `# The following has been auto-generated by "coder config-ssh"
# to make accessing your Coder workspaces easier.
#
# To remove this blob, run:
#
#    coder config-ssh --remove
#
# You should not hand-edit this section, unless you are deleting it.`
const sshEndToken = "# ------------END-CODER-ENTERPRISE------------"

func configSSHCmd() *cobra.Command {
	var (
		configpath string
		remove     = false
		next       = false
	)

	cmd := &cobra.Command{
		Use:   "config-ssh",
		Short: "Configure SSH to access Coder workspaces",
		Long:  "Inject the proper OpenSSH configuration into your local SSH config file.",
		RunE:  configSSH(&configpath, &remove, &next),
	}
	cmd.Flags().StringVar(&configpath, "filepath", ssh.DefaultConfigPath, "override the default path of your ssh config file")
	cmd.Flags().BoolVar(&remove, "remove", false, "remove the auto-generated Coder ssh config")
	cmd.Flags().BoolVar(&next, "next", false, "(alpha) uses coder tunnel to proxy ssh connection")

	return cmd
}

func configSSH(configpath *string, remove *bool, next *bool) func(cmd *cobra.Command, _ []string) error {
	return func(cmd *cobra.Command, _ []string) error {
		ctx := cmd.Context()

		client, err := newClient(ctx, true)
		if err != nil {
			return err
		}

		// Check to see if the P2P is enabled for the deployment.
		wconf, err := client.SiteConfigWorkspaces(ctx)
		if err != nil {
			return xerrors.Errorf("getting site workspace config: %w", err)
		}

		if wconf.EnableP2P && !*next {
			// Nudge the user to use P2P if it's enabled on the platform and they have not provided the '--next' flag.
			fmt.Println("Note: NetworkingV2 is enabled on the coder deployment, use --next to enable it for ssh")
		}
		if !wconf.EnableP2P && *next {
			// Fail out if P2P is disabled and the user has specified the '--next' flag.
			return xerrors.New("NetworkingV2 feature is not enabled, cannot use --next flag")
		}

		config, err := ssh.ReadConfig(ctx, *configpath)
		if err != nil {
			return xerrors.Errorf("read config: %w", err)
		}

		pkeyPath, err := ssh.DefaultPrivateKeyPath()
		if err != nil {
			return xerrors.Errorf("default private key path: %w", err)
		}

		// Since we're (re)configuring, we can unconditionally remove the old coder config.
		removed := config.Remove()

		if *remove {
			if !removed {
				return xerrors.Errorf("the Coder ssh configuration section could not be safely deleted or does not exist")
			}

			err = config.Write()
			if err != nil {
				return xerrors.Errorf("write to ssh config file %q: %s", *configpath, err)
			}
			_ = os.Remove(pkeyPath)

			return nil
		}

		wss, err := getWorkspaces(ctx, client, coder.Me)
		if err != nil {
			return xerrors.Errorf("get workspaces: %w", err)
		}

		err = addWorkspaceConfig(ctx, client, config, *next, wss...)
		if err != nil {
			return xerrors.Errorf("add workspaces config: %w", err)
		}

		err = config.Write()
		if err != nil {
			return xerrors.Errorf("write ssh config: %w", err)
		}

		user, err := client.Me(ctx)
		if err != nil {
			return xerrors.Errorf("get coder user: %w", err)
		}

		err = writeSSHKey(ctx, client)
		if err != nil {
			if !xerrors.Is(err, os.ErrPermission) {
				return xerrors.Errorf("write ssh key: %w", err)
			}
			fmt.Printf("Your private ssh key already exists at \"%s\"\nYou may need to remove the existing private key file and re-run this command\n\n", pkeyPath)
		} else {
			fmt.Printf("Your private ssh key was written to \"%s\"\n", pkeyPath)
		}

		writeSSHUXState(ctx, client, user.ID, wss)
		fmt.Printf("An auto-generated ssh config was written to \"%s\"\n", *configpath)
		fmt.Println("You should now be able to ssh into your workspace")
		fmt.Printf("For example, try running\n\n\t$ ssh coder.%s\n\n", wss[0].Name)
		return nil
	}
}

// sshAvailable returns true if SSH is available for at least one workspace.
func sshAvailable(workspaces []coderutil.WorkspaceWithWorkspaceProvider) bool {
	for _, workspace := range workspaces {
		if workspace.WorkspaceProvider.SSHEnabled {
			return true
		}
	}
	return false
}

func writeSSHKey(ctx context.Context, client coder.Client) error {
	key, err := client.SSHKey(ctx)
	if err != nil {
		return err
	}
	return ssh.WriteSSHKey([]byte(key.PrivateKey))
}

func writeSSHUXState(ctx context.Context, client coder.Client, userID string, workspaces []coder.Workspace) {
	// Create a map of workspace.ID -> true to indicate to the web client that all
	// current workspaces have SSH configured
	cliSSHConfigured := make(map[string]bool)
	for _, workspace := range workspaces {
		cliSSHConfigured[workspace.ID] = true
	}
	// Update UXState that coder config-ssh has been run by the currently
	// authenticated user
	err := client.UpdateUXState(ctx, userID, map[string]interface{}{"cliSSHConfigured": cliSSHConfigured})
	if err != nil {
		clog.LogWarn("The Coder web client may not recognize that you've configured SSH.")
	}
}

func mustParseURL(u string) *url.URL {
	uri, err := url.Parse(u)
	if err != nil {
		panic(err)
	}
	return uri
}

func addWorkspaceConfig(ctx context.Context, client coder.Client, config *ssh.Config, isP2P bool, workspaces ...coder.Workspace) error {
	user, err := client.Me(ctx)
	if err != nil {
		return xerrors.Errorf("fetch username: %w", err)
	}

	// Get the path to the 'coder' binary.
	binPath, err := os.Executable()
	if err != nil {
		return xerrors.Errorf("Failed to get executable path: %w", err)
	}

	wsps, err := coderutil.WorkspacesWithProvider(ctx, client, workspaces)
	if err != nil {
		return xerrors.Errorf("workspace with provider: %w", err)
	}

	// If SSH is disabled bail out early.
	if !sshAvailable(wsps) {
		return xerrors.New("SSH is disabled or not available for any workspaces in your Coder deployment.")
	}

	pkeyPath, err := ssh.DefaultPrivateKeyPath()
	if err != nil {
		return xerrors.Errorf("get private key path: %w", err)
	}

	for _, ws := range wsps {
		if !ws.WorkspaceProvider.SSHEnabled {
			clog.LogWarn(fmt.Sprintf("SSH is not enabled for workspace provider %q, skipping workspace %q", ws.WorkspaceProvider.Name, ws.Workspace.Name),
				clog.BlankLine,
				clog.Tipf("ask an infrastructure administrator to enable SSH for this workspace provider"),
			)
			continue
		}

		config.AddHost(ssh.Host{
			Host:           mustParseURL(ws.WorkspaceProvider.EnvproxyAccessURL).Host,
			Username:       user.Username,
			Workspace:      ws.Workspace.Name,
			PrivateKeyPath: pkeyPath,
			CoderBinPath:   binPath,
			Tunnel:         isP2P,
		})
	}

	return nil
}
